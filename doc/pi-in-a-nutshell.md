# Π in a nutshell

Christiano Braga  
Universidade Federal Fluminense  
http://www.ic.uff.br/~cbraga  
\
March 2019  
\
http://github.com/ChristianoBraga/PiFramework

## Introduction

Π is a simple semantic framework to teach compiler construction
principles. It is comprised of π IR, a language with
Turing-complete-expressive constructions, and Π automaton, a
stack-based machine that gives semantics to Π IR. To construct a
compiler for a language _L_, one needs to define Π denotations:
functions relating the (abstract) syntax of _L_ with Π IR
constructions.

## Π grammar

```
<IR> ::= <Statement>
<OC> ::= <ExpOC> | <CmdOC> | <DecOC> | <AbsOC>
```

## Π automata

A Π automaton is a 5-tuple _A = (G, Q, δ, q₀, F)_, where G is a
context-free grammar, Q is the set of states, q₀ is the initial state,
F ⊆ Q is the set of final states and _𝛅 : L(G)* × L(G)* × Store ⟶   Q_,
where _L(G)_ is the language generated by _G_ and _Store_ represents
the memory.

* Grammar _G_ is the result of the composition of Π IR and Π opcodes: _G = `<IR>` | `<OC>`_.  
* Elements in a set _S*_ are represented by terms _[s₁, s₂, ..., sᵢ]_.  
* 𝛅(∅, V, S) ∈ F, that is, it denotes an _accepting state_.

## Π IR expressions

### Grammar
```
<Statement> ::= <Exp> 

<Exp>       ::= <ArithExp> | <BoolExp> 

<ArithExp>  ::= Num(<digits>) | Sum(<Exp> , <Exp> ) | Sub(<Exp>, <Exp>) | 
                Mul(<Exp>, <Exp>) | Div(<Exp>, <Exp>)

<BoolExp>   ::= Boo(<bool>) | Eq(<Exp>, <Exp>) | Lt(<Exp>, <Exp>) | 
                Le(<Exp>, <Exp>) | Gt(<Exp>, <Exp>) | Ge(<Exp>, <Exp>) | 
                And(<Exp>, <Exp>) | Or(<Exp>, <Exp>) | Not(<Exp>) 

<bool>      ::= True | False
```

### Opcodes
```
<ExpOC>     ::= #SUM | #SUB | #MUL | #DIV |   
                #EQ | #LT | #LE | #GT | #GE | #AND | #OR | #NOT
```

### Automaton
    
Recall that _𝛅 : L(G)* × L(G)* × Store ⟶   Q_, and let _N, Nᵢ ∈ ℕ_ ,
_B, Bᵢ ∈ Bool_, _C, V ∈ L(G)*_, _S ∈ Store_,

_𝛅(Num(N) :: C, V, S) = 𝛅(C, N :: V, S)_  
_𝛅(Sum(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #SUM :: C, V, S)_   
_𝛅(#SUM :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ + N₂ :: V, S)_

_𝛅(Sub(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #SUB :: C, V, S)_   
_𝛅(#SUB :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ - N₂ :: V, S)_

_𝛅(Mul(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #MUL :: C, V, S)_   
_𝛅(#MUL :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ * N₂ :: V, S)_

_𝛅(Div(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #MUL :: C, V, S)_   
_𝛅(#DIV :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ / N₂ :: V, S) if N₂ ≠ 0_

_𝛅(Eq(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #EQ :: C, V, S)_   
_𝛅(#EQ :: C, Boo(B₁) :: Boo(B₂) :: V, S) = 𝛅(C, B₁ = B₂ :: V, S)_

_𝛅(Lt(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #LT :: C, V, S)_   
_𝛅(#LT :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ < N₂ :: V, S)_

_𝛅(Le(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #LE :: C, V, S)_   
_𝛅(#LE :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ ≤ N₂ :: V, S)_

_𝛅(Gt(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #GT :: C, V, S)_   
_𝛅(#GT :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ > N₂ :: V, S)_

_𝛅(Ge(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #GE :: C, V, S)_   
_𝛅(#GE :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ ≥ N₂ :: V, S)_

_𝛅(And(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #AND :: C, V, S)_   
_𝛅(#AND :: C, Boo(B₁) :: Boo(B₂) :: V, S) = 𝛅(C, B₁ ∧ B₂ :: V, S)_

_𝛅(Or(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #OR :: C, V, S)_   
_𝛅(#OR :: C, Boo(B₁) :: Boo(B₂) :: V, S) = 𝛅(C, B₁ ∨ B₂ :: V, S)_

_𝛅(Not(E) :: C, V, S) = 𝛅(E :: #NOT :: C, V, S)_   
_𝛅(#NOT :: C, Boo(True) :: V, S) = 𝛅(C, False :: V, S)_   
_𝛅(#NOT :: C, Boo(False) :: V, S) = 𝛅(C, True :: V, S)_   

* Notation _h :: ls_ denotes the concatenation of element _h_ with the list _ls_. 

* _C_ represents the _control_ stack. _V_ represents the  _value_ stack. _S_ denotes the memory store.

* On a particular implementation of the Π Framework, as in Python,
`<digits>` and `<bool>` denote built-in numbers and Boolean values in
the chosen implementation language, such that all arithmetic
operations and Boolean operations, such as `+` and `or`, are defined.
That's why _Nᵢ_ are Natural numbers and _Bᵢ_ are Boolean values.

## Π IR commands

### Grammar

Commands are language constructions that require a _memory store_ to be evaluated. 

```
<Statement> ::= <Cmd> 


<Exp>       ::= Id(<String>) 
<Cmd>       ::= Nop | Assign(<Id>, <Exp>) | Loop(<BoolExp>, <Cmd>) | 
                CSeq(<Cmd>, <Cmd>) | Cond(<BoolExp>, <Cmd>, <Cmd>)
```

### Opcodes
```
<CmdOC>     ::= #ASSIGN | #LOOP | #COND
```

### Automaton

* A location _l ∈ Loc_ denotes a memory cell.
* _Storable_ and _Bindable_ sets denote the data that may be mapped to
  by identifiers and locations on the memory and environment
  respectively.
* _Store = Id ↦ Storable_, _Env = Loc ↦ Bindable_, where A ↦ B denotes the
  finite map between sets A and B.
* _Loc ⊆ Storable_, _ℕ ⊆ Storable_, and _ℕ ⊆ Bindable_.
* The transition function is _𝛅 : L(G)* × L(G)* × Env × Store ⟶   Q_,
  and let _W ∈ String_, _C, V ∈ L(G)*_, _S ∈ Store_, _E ∈ Env_, _B ∈
  Bindable_, _l ∈ Loc_, _T ∈ Storable_, _X ∈ `<Exp>`_, _M, M₁, M₂ ∈
  `<Cmd>`_,and expression _S' = S/(l ↦ N)_ means that _S'_ equals to
  _S_ in all indices but _l_ where it is bound to _N_,

_𝛅(Id(W) :: C, V, E, S) = 𝛅(C, B :: V, E, S)_, where _E[W] = l ∧ S[l] = B_,

_𝛅(Assign(W, X) :: C, V, E, S) =  𝛅(X :: #ASSIGN :: C, W :: V, E, S')_,   
_𝛅(#ASSIGN :: C, T :: W :: V, E, S) = 𝛅(C, V, E, S')_, where _E[W] = l ∧ S' = S/(l ↦ T)_, 

_𝛅(Loop(X, M) :: C, V, E, S) =  𝛅(X :: #LOOP :: C, Loop(X, M) :: V, E, S)_,  
_𝛅(#LOOP :: C, true :: Loop(X, M) :: V, E, S) = 𝛅(M :: Loop(X, M) :: C, V, E, S)_,  
_𝛅(#LOOP :: C, false :: Loop(X, M) :: V, E, S) = 𝛅(C, V, E, S)_, 

_𝛅(Cond(X, M₁, M₂) :: C, V, E, S) =  𝛅(X :: #COND :: C, Cond(X, M₁, M₂) :: V, E, S)_,  
_𝛅(#COND :: C, true :: Cond(X, M₁, M₂) :: V, E, S) = 𝛅(M₁ :: C, V, E, S)_,  
_𝛅(#COND :: C, false :: Cond(X, M₁, M₂) :: V, E, S) = 𝛅(M₂ :: C, V, E, S)_, 

_𝛅(CSeq(M₁, M₂) :: C, V, E, S) = 𝛅(M₁ :: M₂ :: C, V, E, S)_.

## Π IR declarations

### Grammar

* Declarations are statements that create an environment, binding identifiers to (bindable) values.
* In Π IR, a bindable value is either a Boolean value, an integer or a location. 
* From a syntactic standpoint, all classes are monotonically extended.

```
<Statement> ::= <Dec> 

<Exp>       ::= Ref(<Exp>)> | DeRef(<Id>) | ValRef(<Id>)

<Dec>       ::= Bind(<Id>, <Exp>) | DSeq(<Dec>, <Dec>)

<Cmd>       ::= Blk(<Dec>, <Cmd>) 
```

### Opcodes
```
<DecOC>     ::= #REF | #BLKDEC | #BLKCMD | #BIND | #DSEQ
```

### Automaton

Let _BlockLocs_ = 𝒫(Loc), the transition function be _𝛅 : L(G)* ×
L(G)* × Env × Store × BlockLocs ⟶   Q_, and let _L, L' ∈ BlockLocs_,
_Loc ⊆ Storable_, and _S / L = { l ↦ T | l ↦ T ∈ S ∧ l ∉ L}_, that
is, the store _S_ without the mappings whose locations are in _L_,

_𝛅(Ref(X) :: C, V, E, S, L) = 𝛅(X :: #REF :: C, V, E, S, L)_,   
_𝛅(#REF :: C, T :: V, E, S, L) = 𝛅(C, l :: V, E, S', L')_, where _S' = S ∪ [l ↦ T], l ∉ S, L' = L ∪ {l}_, 

_𝛅(DeRef(Id(W)) :: C, V, E, S, L) = 𝛅(C, l :: V, E, S, L)_, where _l = E[W]_,  

_𝛅(ValRef(Id(W)) :: C, V, E, S, L) = 𝛅(C, T :: V, E, S, L)_, where _T = S[S[E[W]]]_,  

_𝛅(Bind(Id(W), X) :: C, V, E, S, L) = 𝛅(X :: #BIND :: C, W :: V, E, S, L)_,   
_𝛅(#BIND :: C, B :: W :: E' :: V, E, S, L) = 𝛅(C, ({W ↦ B} ∪ E') :: V, E, S, L)_, where _E' ∈ Env_,  
_𝛅(#BIND :: C, B :: W :: H :: V, E, S, L) = 𝛅(C, {W ↦ B} :: H :: V, E, S, L)_, where _H ∉ Env_,  

_𝛅(DSeq(D₁, D₂), X) :: C, V, E, S, L) = 𝛅(D₁ :: D₂ :: C, V, E, S, L)_, 

_𝛅(Blk(D, M) :: C, V, E, S, L) = 𝛅(D :: #BLKDEC :: M :: #BLKCMD :: C, L :: V, E, S, ∅)_,   
_𝛅(#BLKDEC :: C, E' :: V, E, S, L) = 𝛅(C, E :: V, E / E', S, L)_,   
_𝛅(#BLKCMD :: C, E :: L :: V, E', S, L') = 𝛅(C, V, E, S', L)_, where _S' = S / L'_.

## Π IR abstractions

### Grammar

Abstractions extend Bindables by allowing a name to be bound to a list
of formal parameters, a list of identifiers, and a block in the
environment.  Such names can be called and applied to actual
parameters, a list of expressions.

```
<Dec>     ::= Bind(<Id>, <Abs>) 

<Abs>     ::= Abs(<Formals>, <Blk>) 

<Formals> ::= <Id>*

<Cmd>     ::= Call(<Id>, <Actuals>)

<Actuals> ::= <Exp>*
```

### Automaton

#### Closures

We chose a static binding semantics for abstractions. Therefore, we
interpret abstractions as _closures_ formed by an abstraction together
with its declaration environment which defines the context in which
the abstraction will be evaluated.

_Closure : Formals × Blk × Env ⟶   Bindable_ 

#### Abstractions

Let _F ∈ Formals_, _B ∈ Blk_, _I ∈ Id_, _A ∈ Actuals_, _Vᵢ ∈ Value_, _1 ≤ i ≤ u_, _u ∈ ℕ_,  

_𝛅(Abs(F, B) :: C, V, E, S, L) = 𝛅(C, Closure(F, B, E) :: V, E, S, L)_   

_𝛅(Call(I, [X₁, X₂, ..., Xᵤ])) :: C, V, E, S, L) =   
_𝛅(Xᵤ:: Xᵤ₋₁ :: ... :: X₁ :: #CALL(I, u) :: C, V, E, S, L)_   
_𝛅(#CALL(I, u) ::C, [V₁, V₂, ..., Vᵤ] :: V, {I ↦ Closure(F, B, E₁)} ∪ E₂, S, L) =_  
    _𝛅(B :: #BLKCMD :: C, E₂ :: V, (E₁ / match(F, [V₁, V₂, ..., Vᵤ])), S, L)_   

_match : Id* × Values* ⟶   Env_  
_match(fl, al) = if |fl| ≠ |al| than {} else match-aux(fl, al, {})_   
_match-aux : Id* × Values* × Env ⟶   Env_   
_match-aux([], [], E) = E_    
_match-aux(f, a, E) = {f ↦ a} ∪ E_  
_match-aux(f :: fl, a :: al, E) = match-aux(fl), al, {f ↦ a} ∪ E)_
